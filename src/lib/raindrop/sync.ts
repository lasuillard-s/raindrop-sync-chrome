import { client, generated } from '@lasuillard/raindrop-client';
import { NodeData, TreeNode } from '~/lib/sync/tree';
import { normalizeUrl } from '~/lib/util/string';

type GetRootCollectionsResponseItem = generated.GetRootCollectionsResponse['items'][0];
type GetChildCollectionsResponseItem = generated.GetChildCollectionsResponse['items'][0];
type GetAllRaindropsResponseItem = generated.GetRaindropsResponse['items'][0];

/** Raindrop collection or bookmark items. */
export type RaindropItem =
	| GetRootCollectionsResponseItem
	| GetChildCollectionsResponseItem
	| GetAllRaindropsResponseItem;

export class RaindropNodeData extends NodeData {
	rawData: RaindropItem;

	constructor(data: RaindropItem) {
		super();
		this.rawData = data;
	}

	// Raindrop.io internal ID
	getId(): string {
		return this.rawData._id.toString();
	}

	getParentId(): string | null {
		const parentId: string | null =
			// @ts-expect-error Multi-type handling; consider type guards
			this.rawData.parent?.$id.toString() || this.rawData.collection?.$id.toString() || null;

		// ? Root for raindrops is -1 (unsorted) if it does not belong to any collection
		// ? So to make sure tree build work properly, redirect the value
		if (parentId === '-1') {
			return null;
		}

		return parentId;
	}

	getHash(): string {
		let hash: string | null | undefined;
		if (this.isFolder()) {
			hash = this.getName();
		} else {
			// * Chrome handles redirection so URL changes after saved to bookmarks
			hash = normalizeUrl(this.getUrl() || '');
		}
		return hash || Math.random().toString();
	}

	getName(): string {
		return this.rawData.title;
	}

	getUrl(): string | null {
		// @ts-expect-error Multi-type handling
		return this.rawData.link || null;
	}

	isFolder(): boolean {
		return this.rawData && !Object.hasOwn(this.rawData, 'link');
	}
}

/**
 * Fetch all raindrops with pagination handling.
 * @param raindropClient Raindrop.io client
 * @param collectionId Collection ID to fetch raindrops from
 * @param params Optional parameters
 * @param params.sort Sort order
 * @param params.pageSize Number of items per page
 * @param params.search Search query
 * @returns List of raindrop items
 */
async function getAllRaindrops(
	raindropClient: client.Raindrop,
	collectionId?: number,
	params?: {
		sort?: string;
		pageSize?: number;
		search?: string;
	}
	// biome-ignore lint/suspicious/noExplicitAny: Autogenerated code
): Promise<RaindropItem[]> {
	const collection = collectionId ?? 0; // System collection for ALL, **EXCEPT IN TRASH**
	const sort = params?.sort ?? '';
	const pageSize = params?.pageSize ?? 50;
	const search = params?.search ?? '';
	const { data: head } = await raindropClient.raindrop.getRaindrops(
		collection,
		sort,
		pageSize,
		0,
		search
	);

	// Calculate how many should iterate over from first head response, using `$.count` value
	const count = head.count;
	const maxPage = Math.ceil(count / pageSize);

	// Range of pages
	const pageNumbers = Array.from(Array(maxPage).keys());
	pageNumbers.shift(); // But without head already fetched

	const results = await Promise.all(
		pageNumbers.map((page) =>
			raindropClient.raindrop
				.getRaindrops(collection, sort, pageSize, page, search)
				.then(({ data }) => data)
		)
	);

	// Concatenate all items
	const items = [...head.items];
	for (const data of results) {
		items.push(...data.items);
	}

	return items;
}
/**
 * Creates a tree structure from Raindrop.io collections.
 * @param raindropClient Raindrop.io client
 * @returns Root node of the tree
 */
export async function createTreeFromRaindrops(
	raindropClient: client.Raindrop
): Promise<TreeNode<RaindropNodeData>> {
	const [{ data: groups }, { data: collections }, raindrops] = await Promise.all([
		raindropClient.collection.getRootCollections(),
		raindropClient.collection.getChildCollections(),
		getAllRaindrops(raindropClient, 0 /* ALL */)
	]);

	const groupNodes = groups.items.map((group) => new RaindropNodeData(group));
	const collectionNodes = collections.items.map((collection) => new RaindropNodeData(collection));
	const raindropNodes = raindrops.map((raindrop) => new RaindropNodeData({ ...raindrop }));

	// Merge all nodes
	const allNodes = [...groupNodes, ...collectionNodes, ...raindropNodes];

	// Deduplicate items
	// ? Need to check and update the API client to avoid duplicates in the first place
	const uniqueNodes = allNodes.filter(
		(left, index, self) => index === self.findIndex((right) => right.getId() === left.getId())
	);

	// TODO(#165): Sort nodes as same in raindrop.io; pending for check & review
	// allNodes.sort((a, b) => a.rawData.sort.toString().localeCompare(b.rawData.sort.toString()));

	return TreeNode.createTree(null, uniqueNodes);
}
